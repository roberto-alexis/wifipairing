/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package wifipairing;

import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;
import java.util.stream.Collectors;

import static java.lang.System.exit;

public class App {
    private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
    private final String printerUrl;
    private final String encryptionKey;

    public static void main(String[] args) {
        if (args.length != 3) {
            log("Usage: {endpoint} {encryptionKey} {message}");
            exit(-1);
        }
        App app = new App(args[0], args[1]);
        app.sendMessage(args[2]);
        exit(0);
    }

    private App(String printerUrl, String encryptionKey) {
        this.printerUrl = printerUrl;
        this.encryptionKey = encryptionKey;
    }

    private void sendMessage(String message) {
        try(CloseableHttpClient client = HttpClients.createDefault()) {
            HttpPost httpPost = new HttpPost(printerUrl);
            log("Message: " + message);
            String encryptedMessage = encrypt(encryptionKey, message);
            log("Encrypted message: " + encryptedMessage);
            httpPost.setEntity(new StringEntity(encryptedMessage));
            CloseableHttpResponse result = client.execute(httpPost);
            if (result.getStatusLine().getStatusCode() != 200) {
                log("Error sending message: " + result.getStatusLine());
            } else {
                InputStream inputStream = result.getEntity().getContent();
                String encryptedResponse =new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))
                        .lines()
                        .collect(Collectors.joining("\n"));
                log("Encrypted response: " + encryptedResponse);
                String response = decrypt(encryptionKey, encryptedResponse);
                log("Response: " + response);
            }
        } catch (Throwable error) {
            log("Unable to send message: " + error);
        }
    }

    private String encrypt(String encryptionKey, String body) {
        Cipher cipher = createCipher(true, encryptionDigest(encryptionKey));

        byte[] bodyBytes = body.getBytes(StandardCharsets.UTF_8);
        int blockSize = cipher.getBlockSize();
        int padLength = padLength(bodyBytes.length, blockSize);
        byte[] bodyPad = new byte[Math.addExact(bodyBytes.length, padLength)];
        System.arraycopy(bodyBytes, 0, bodyPad, 0, bodyBytes.length);

        try {
            byte[] encrypted = cipher.doFinal(bodyPad);
            return Base64.getEncoder().encodeToString(encrypted);
        } catch (IllegalBlockSizeException | BadPaddingException error) {
            throw new IllegalStateException("Unable to encrypt", error);
        }
    }

    private String decrypt(String encryptionKey, String body) {
        Cipher cipher = createCipher(false, encryptionDigest(encryptionKey));

        try {
            byte[] bodyBytes = Base64.getDecoder().decode(body);
            byte[] decrypted = cipher.doFinal(bodyBytes);
            String result = new String(decrypted, StandardCharsets.UTF_8);
            return result.trim();
        } catch (IllegalBlockSizeException | BadPaddingException error) {
            throw new IllegalStateException("Unable to decrypt", error);
        }
    }

    public byte[] encryptionDigest(String encryptionKey) {
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            byte[] keyMd5Bytes = md5.digest(encryptionKey.getBytes(StandardCharsets.UTF_8));
            keyMd5Bytes = Arrays.copyOf(keyMd5Bytes, 16);
            log("Key digest: " + bytesToHex(keyMd5Bytes));
            return keyMd5Bytes;
        } catch (NoSuchAlgorithmException error) {
            throw new IllegalStateException("Unable to generate MD5 digest", error);
        }
    }

    private Cipher createCipher(boolean encrypt, byte[] keyMd5Bytes) {
        try {
            Cipher cipher = Cipher.getInstance("AES/CBC/NoPadding");
            SecretKeySpec skeySpec = new SecretKeySpec(keyMd5Bytes, "AES");
            IvParameterSpec iv = new IvParameterSpec(keyMd5Bytes);
            cipher.init(encrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, skeySpec, iv);
            return cipher;
        } catch (NoSuchPaddingException | NoSuchAlgorithmException | InvalidAlgorithmParameterException | InvalidKeyException error) {
            throw new IllegalStateException("Unable to configure cypher", error);
        }
    }

    private static int padLength(int len, int blockSize) {
        return blockSize - (len % blockSize);
    }

    private static void log(String message) {
        System.out.println(message);
    }

    private static String bytesToHex(byte[] bytes) {
        char[] hexChars = new char[bytes.length * 2];
        for (int j = 0; j < bytes.length; j++) {
            int v = bytes[j] & 0xFF;
            hexChars[j * 2] = HEX_ARRAY[v >>> 4];
            hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
        }
        return new String(hexChars);
    }
}
